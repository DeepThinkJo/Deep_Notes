{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"index.html","title":"Deep Notes","text":"<p>Deep Thinking. Purposeful Engineering.</p>"},{"location":"index.html#what-is-deep-notes","title":"What is Deep Notes?","text":"<p>Deep Notes is my personal knowledge archive for Mathematics, Computer Science, and AI Engineering. It is built on a simple belief:</p> <p>Good engineering begins with deep thinking. Understanding the \u201cwhy\u201d makes the \u201chow\u201d meaningful.</p> <p>Every page in this archive reflects a commitment to:  </p> <ul> <li>Deep exploration rather than surface-level memorization  </li> <li>Structured reasoning rather than trial-and-error  </li> <li>Purposeful engineering grounded in fundamentals  </li> </ul> <p>This space grows alongside my journey as an AI engineer.</p>"},{"location":"index.html#why-i-study-in-depth","title":"Why I Study in Depth","text":"<p>Engineering is problem-solving \u2014 but not just through tools or code. Real engineering starts with:</p> <ul> <li>Identifying the core structure of a problem  </li> <li>Understanding its constraints and purpose </li> <li>Designing with clarity, intention, and reasoning </li> </ul> <p>This is the essence of DeepThinkJo, the philosophy behind this archive: Think deeply \u2192 Understand fundamentally \u2192 Engineer intentionally.</p>"},{"location":"index.html#subjects-in-this-archive","title":"Subjects in This Archive","text":"<p>This repository will contain notes on:</p>"},{"location":"index.html#mathematics","title":"Mathematics","text":"<ul> <li>Linear Algebra  </li> <li>Calculus  </li> <li>Probability &amp; Statistics</li> <li>Optimization</li> </ul>"},{"location":"index.html#computer-science","title":"Computer Science","text":"<ul> <li>Algorithms  </li> <li>Data Structures  </li> <li>Systems &amp; Architecture Basics</li> <li>Python</li> <li>C/C++</li> </ul>"},{"location":"index.html#ai-machine-learning","title":"AI &amp; Machine Learning","text":"<ul> <li>Deep Learning Foundations  </li> <li>Optimization  </li> <li>Model Architecture Concepts  </li> <li>Practical Engineering Notes  </li> </ul> <p>Each topic is written with both conceptual clarity and engineering application in mind.</p>"},{"location":"index.html#how-this-archive-works","title":"How This Archive Works","text":"<p>This site is automatically generated from my Notion notes. Every time I update a note in Notion:</p> <ol> <li>The content is synced into Markdown  </li> <li>Markdown files are pushed to this GitHub repository  </li> <li>GitHub Pages regenerates this site automatically  </li> </ol> <p>This allows my learning process to stay:  </p> <ul> <li>Consistent</li> <li>Organized</li> <li>Engineering-oriented</li> </ul>"},{"location":"index.html#my-philosophy-as-an-ai-engineer","title":"My Philosophy as an AI Engineer","text":"<p>Deep \u2014 Explore underlying structures and understand the foundations. Think \u2014 Reason before coding; design before implementing.  </p> <p>Engineering is not only about building systems, but about building them with purpose, clarity, and depth.</p>"},{"location":"index.html#welcome-to-deep-notes","title":"Welcome to Deep Notes","text":"<p>This is a long-term project \u2014 a living archive of what I learn, understand, and build. If you\u2019d like to explore how I think and grow as an AI engineer, you\u2019re in the right place.</p>"},{"location":"Computer_Science/Python/chapter_1_introduction_to_programming_and_python.html","title":"Chapter 1. Introduction to Programming and Python","text":"<p>As engineers, our goal is to solve problems by applying scientific principles and systematic thinking.</p> <p>Computer engineering focuses on solving problems with the aid of computers\u2014powerful tools capable of executing procedures quickly and reliably.</p> <p>However, computers differ fundamentally from humans.</p> <p>Humans can interpret vague instructions and understand context, but computers require explicit, precise commands to perform any task.</p> <p>They cannot figure things out on their own; they must be told exactly what to do and how to do it.</p> <p>Therefore, solving problems with computers requires more than intuition.</p> <p>We must express our solution process in a way the computer can understand.</p> <p>This activity is called programming.</p> <p>We do not study Python to memorize syntax.</p> <p>Our purpose is to learn how to communicate problem-solving ideas to a computer.</p> <p>Python is one tool\u2014a programming language that allows us to express solutions clearly and effectively.</p> <p>Ultimately, our goal is not to accumulate knowledge, but to build the ability to use computation to solve real problems.</p> <p>This chapter provides the conceptual foundation for understanding computers, programming, and why Python is such an effective tool for modern engineering.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2_python_programming_basics.html","title":"Chapter 2. Python Programming Basics","text":"<p>In Chapter 1, we explored the context behind programming:</p> <p>why computers exist, what computer engineering aims to accomplish, and how programming functions as a tool for solving real-world problems.</p> <p>Now, in Chapter 2, we shift from concepts to practice.</p> <p>This chapter establishes the essential foundations that every Python program is built upon.</p> <p>You are not learning \u201csyntax\u201d for its own sake.</p> <p>You are learning how to express a solution to a problem in the language of Python.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2_python_programming_basics.html#why-python-basics-matter","title":"Why Python Basics Matter","text":"<p>Every advanced topic in computer science\u2014data structures, algorithms, systems programming, machine learning, optimization\u2014ultimately depends on the same basic questions:</p> <ul> <li>What is data?</li> <li>How is it stored?</li> <li>How do we operate on it?</li> <li>How does a program decide what to do next?</li> <li>How do we handle unexpected situations?</li> <li>How do we structure code so that both humans and machines can understand it clearly?</li> </ul>","tags":[]},{"location":"Computer_Science/Python/chapter_2_python_programming_basics.html#what-this-chapter-covers","title":"What This Chapter Covers","text":"<ul> <li>Data and Variables</li> <li>Basic Data Types</li> <li>Operators and Expressions</li> <li>Input and Output</li> <li>Control Flow</li> <li>Functions</li> <li>Basic Error Handling</li> <li>Code Style</li> </ul>","tags":[]},{"location":"Computer_Science/Python/chapter_2_python_programming_basics.html#learning-philosophy","title":"Learning Philosophy","text":"<p>Each concept exists because it solves a specific problem:</p> <ul> <li>Variables give names to data.</li> <li>Data types define how information behaves.</li> <li>Control flow allows decisions.</li> <li>Functions allow modular design.</li> <li>Error handling protects programs from failure.</li> </ul> <p>Ask yourself:</p> <p>\u201cWhat problem does this concept solve?\u201d</p>","tags":[]},{"location":"Computer_Science/Python/chapter_3_python_data_structures.html","title":"Chapter 3 \u2014 Python Data Structures: Organizing Information for Problem Solving","text":"<p>In Chapter 2, we learned how Python represents data at the most fundamental level.</p> <p>But real-world problems involve collections of information.</p> <p>To solve complex problems, we need a way to store, organize, transform, and retrieve structured data efficiently.</p> <p>This is where data structures become essential.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_3_python_data_structures.html#why-data-structures-matter","title":"Why Data Structures Matter","text":"<p>Data structures determine:</p> <ul> <li>how quickly we can access information</li> <li>whether duplicates are allowed</li> <li>whether order matters</li> <li>whether data can be modified</li> <li>how easy it is to transform data</li> <li>how stable a program remains as it grows</li> </ul> <p>They form the interface between high-level logic and memory.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_3_python_data_structures.html#pythons-built-in-data-structures","title":"Python\u2019s Built-In Data Structures","text":"<ul> <li>strings (str): immutable sequences of characters</li> <li>lists: mutable ordered collections</li> <li>tuples: immutable ordered collections</li> <li>dictionaries (dict): key\u2013value mappings</li> <li>sets: unique collections</li> </ul> <p>These are not just containers\u2014they define how information behaves.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_3_python_data_structures.html#data-structures-and-problem-solving","title":"Data Structures and Problem Solving","text":"<p>Real data requires:</p> <ul> <li>sequences</li> <li>mappings</li> <li>sets for uniqueness</li> <li>composite structures</li> </ul> <p>Mastering Python\u2019s data structures prepares you for scientific computing, data science, and AI.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_1/sec_1_introduction_to_computer_engineering.html","title":"1.1 Introduction to Computer Engineering","text":"","tags":[]},{"location":"Computer_Science/Python/chapter_1/sec_1_introduction_to_computer_engineering.html#what-is-computer-engineering","title":"What is Computer Engineering?","text":"<p>A computer is a tool designed to perform repetitive, precise, and tedious calculations on our behalf.</p> <p>Computer engineering studies how computers are built, how they operate, and how we can use them to solve problems efficiently.</p> <p>While computer science emphasizes theories of computation,</p> <p>computer engineering focuses on the design and practical use of computer systems.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_1/sec_1_introduction_to_computer_engineering.html#fundamental-components-of-a-computer","title":"Fundamental Components of a Computer","text":"<p>A computer consists of several essential hardware components:</p> <ul> <li>CPU (Central Processing Unit) \u2014 executes instructions</li> <li>Memory (RAM) \u2014 stores data and instructions currently in use</li> <li>I/O Devices \u2014 allow interaction with the external world These components work together to enable computation.</li> </ul>","tags":[]},{"location":"Computer_Science/Python/chapter_1/sec_1_introduction_to_computer_engineering.html#layered-structure-of-computer-systems","title":"Layered Structure of Computer Systems","text":"<p>Computer systems are organized into layers of abstraction:</p> <ul> <li>Hardware \u2014 physical components such as CPU, memory, and I/O</li> <li>Operating System (OS) \u2014 manages hardware and provides system services</li> <li>Software \u2014 applications and programs written by developers</li> </ul> <p>Programming occurs at the software layer, expressing problem-solving procedures that the OS and hardware ultimately execute.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_1/sec_2_introduction_to_programming.html","title":"1.2 Introduction to Programming","text":"","tags":[]},{"location":"Computer_Science/Python/chapter_1/sec_2_introduction_to_programming.html#what-is-a-program","title":"What Is a Program?","text":"<p>A program is a precise set of instructions that a machine follows to solve a problem.</p> <p>These instructions must be clear and unambiguous so that the computer behaves exactly as intended.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_1/sec_2_introduction_to_programming.html#what-is-programming","title":"What Is Programming?","text":"<p>Programming is the process of designing and writing instructions that enable a computer to carry out steps required to solve a problem.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_1/sec_2_introduction_to_programming.html#who-is-a-programmer","title":"Who Is a Programmer?","text":"<p>A programmer is someone who uses programming to solve problems by expressing procedures in a form the computer can execute accurately.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_1/sec_2_introduction_to_programming.html#why-do-we-learn-programming","title":"Why Do We Learn Programming?","text":"<p>Learning programming is about developing the ability to use computers for problem solving, not about memorizing syntax.</p> <p>Programming teaches us to define problems clearly and express solutions precisely so that a machine can perform them.</p> <p>Ultimately, programming extends our problem-solving capabilities through computation.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_1/sec_3_introduction_to_python.html","title":"1.3 Introduction to Python","text":"","tags":[]},{"location":"Computer_Science/Python/chapter_1/sec_3_introduction_to_python.html#what-is-a-programming-language","title":"What Is a Programming Language?","text":"<p>A programming language is a formal system for expressing instructions that a computer can execute.</p> <p>It serves as an interface between humans and machines, allowing us to describe procedures clearly and precisely.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_1/sec_3_introduction_to_python.html#python-as-a-programming-language","title":"Python as a Programming Language","text":"<p>Python is one of many programming languages.</p> <p>It emphasizes readability and simplicity, making it suitable for both beginners and experts.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_1/sec_3_introduction_to_python.html#core-characteristics-of-python","title":"Core Characteristics of Python","text":"<ul> <li>Interpreted \u2014 executes code line by line</li> <li>High-level \u2014 abstracts away hardware details</li> <li>Dynamically typed \u2014 types are determined at runtime</li> <li>Multi-paradigm \u2014 supports procedural, object-oriented, and functional programming</li> <li>Readable syntax \u2014 easy-to-understand structure</li> </ul>","tags":[]},{"location":"Computer_Science/Python/chapter_1/sec_3_introduction_to_python.html#advantages-of-python","title":"Advantages of Python","text":"<ul> <li>Rich ecosystem with countless libraries and frameworks</li> <li>Strong community support</li> <li>Ideal for AI and data science (NumPy, pandas, PyTorch, TensorFlow)</li> <li>Versatile across domains including web, automation, scripting, finance, and scientific research</li> </ul>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_1_data_and_variables.html","title":"2.1 Data and Variables","text":"","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_1_data_and_variables.html#what-is-data","title":"What Is Data?","text":"<p>Data is information that a computer stores and processes.</p> <p>At the lowest level, all data is represented as bits (0s and 1s).</p> <p>Eight bits form a byte, the basic unit of digital storage.</p> <p>Computers ultimately manipulate only these binary patterns, regardless of whether the data represents numbers, text, or something more complex.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_1_data_and_variables.html#how-computers-store-data","title":"How Computers Store Data","text":"<p>Computers store data in memory (RAM).</p> <p>Memory consists of many storage locations, each with a unique address.</p> <p>When the computer needs to work with a value (such as a number or a string), that value is placed somewhere in memory.</p> <p>The CPU reads and writes data to memory using these numeric addresses.</p> <p>However, these raw addresses are inconvenient for humans to use.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_1_data_and_variables.html#what-is-a-variable","title":"What Is a Variable?","text":"<p>A variable is a name given to a value stored in memory.</p> <p>Instead of remembering a memory address like <code>0x7ffde310</code> , we assign a readable label\u2014such as <code>age</code>, <code>total</code>, or <code>message</code>.</p> <p>When we write:</p> <p><pre><code>x = 10\n</code></pre> Python stores the value <code>10</code> in memory and binds the name <code>x</code> to that location.</p> <p>Memory stores data, and variables give us names to access that data.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_1_data_and_variables.html#variable-naming-rules","title":"Variable Naming Rules","text":"<p>Python variable names must follow certain rules:</p> <ul> <li>Use letters, digits, and underscores (<code>_</code>)</li> <li>Cannot start with a digit</li> <li>No spaces allowed</li> <li>Cannot use reserved keywords (<code>for</code>, <code>if</code>, <code>class</code>, etc.)</li> <li>Case-sensitive (<code>Age</code> and <code>age</code> are different)</li> </ul> <p>Good variable names should be descriptive and readable.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_2_basic_data_types.html","title":"2.2 Basic Data Types","text":"","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_2_basic_data_types.html#why-do-we-need-data-types","title":"Why Do We Need Data Types?","text":"<p>A computer processes many different kinds of information\u2014numbers, text, logical values, and more.</p> <p>To handle these correctly, the programming language must know what kind of data it is dealing with.</p> <p>Python assigns a data type to every value, which determines:</p> <ul> <li>what operations the value can participate in</li> <li>how much memory the value needs</li> <li>how Python interprets the value during execution Understanding data types is essential for writing correct programs.</li> </ul>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_2_basic_data_types.html#pythons-fundamental-data-types","title":"Python\u2019s Fundamental Data Types","text":"","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_2_basic_data_types.html#integers-int","title":"Integers (<code>int</code>)","text":"<p>Whole numbers, such as <code>3</code>, <code>0</code>, <code>-12</code>.</p> <p>Integers support arithmetic operations and are stored exactly.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_2_basic_data_types.html#floating-point-numbers-float","title":"Floating-point numbers (<code>float</code>)","text":"<p>Numbers with decimal points, such as <code>3.14</code> or <code>0.001</code>.</p> <p>They are approximations because they follow binary floating-point representation.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_2_basic_data_types.html#strings-str","title":"Strings (<code>str</code>)","text":"<p>A sequence of characters enclosed in quotes.</p> <p>Strings represent text and support operations such as concatenation and indexing.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_2_basic_data_types.html#booleans-bool","title":"Booleans (<code>bool</code>)","text":"<p>Logical values: <code>True</code> or <code>False</code>.</p> <p>Used in comparisons and conditional statements.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_2_basic_data_types.html#none-nonetype","title":"None (<code>NoneType</code>)","text":"<p>A special value that represents \u201cno value\u201d or \u201cnothing.\u201d</p> <p>Frequently used to indicate the absence of a result.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_2_basic_data_types.html#deep-thoughts-of-jo-why-floating-point-numbers-are-approximations","title":"Deep Thoughts of Jo \u2014 Why Floating-Point Numbers Are Approximations","text":"<p>When Python stores a floating-point number, it does not store it exactly.</p> <p>Computers use finite binary memory to represent numbers, and many decimal values cannot be expressed exactly in binary.</p> <p>Values like 0.1 or 0.2 become infinite repeating fractions, so Python stores the closest possible approximation.</p> <p>This phenomenon is known as floating-point precision error \u2014 a fundamental limitation of digital computation.</p> <p>Later, you will learn how numerical errors arise and how engineers design stable algorithms despite these limitations.</p> <p>For now, remember: floating-point numbers are approximations, not exact values.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_2_basic_data_types.html#checking-the-data-type-type","title":"Checking the Data Type: <code>type()</code>","text":"<p>The <code>type()</code> function reveals the type of any value or variable:</p> <pre><code>type(3)        # int\ntype(\"Hello\")  # str\ntype(True)     # bool\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_2_basic_data_types.html#casting-type-conversion","title":"Casting (Type Conversion)","text":"<p>Sometimes we need to convert a value from one type to another.</p> <p>This process is called casting.</p> <p>Common casting functions:</p> <ul> <li><code>int(\"10\")</code> \u2192 <code>10</code></li> <li><code>float(\"3.5\")</code> \u2192 <code>3.5</code></li> <li><code>str(42)</code> \u2192 <code>\"42\"</code></li> <li><code>bool(0)</code> \u2192 <code>False</code>, <code>bool(1)</code> \u2192 <code>True</code></li> </ul> <p>Casting helps control how data behaves in expressions.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_3_operators_and_expressions.html","title":"Operators and Expressions","text":"","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_3_operators_and_expressions.html#what-are-operators-and-expressions","title":"What Are Operators and Expressions?","text":"<p>Operators are symbols that tell Python to perform specific actions on values or variables.</p> <p>They allow us to combine values, compare them, and express logic within a program.</p> <p>An operator used together with values or variables forms an expression, which Python evaluates to produce a result.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_3_operators_and_expressions.html#assignment-operator","title":"Assignment Operator (<code>=</code>)","text":"<p>The assignment operator stores a value in a variable:</p> <p><pre><code>x = 10\n</code></pre> This means the value <code>10</code> is stored in memory, and the variable <code>x</code> refers to that value.</p> <p>Assignment is not a comparison\u2014it is a binding of a name to a value.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_3_operators_and_expressions.html#arithmetic-operators","title":"Arithmetic Operators","text":"<p>Arithmetic operators perform mathematical operations:</p> <ul> <li><code>+</code> (addition)</li> <li><code>-</code> (subtraction)</li> <li><code>*</code> (multiplication)</li> <li><code>/</code> (true division)</li> <li><code>//</code> (floor division)</li> <li><code>%</code> (modulo)</li> <li><code>**</code> (exponentiation)</li> </ul> <p>Python\u2019s arithmetic operators also apply to certain non-numeric types:</p> <ul> <li><code>\"Hello\" + \"World\"</code> \u2192 <code>\"HelloWorld\"</code></li> <li><code>\"Hi\" * 3</code> \u2192 <code>\"HiHiHi\"</code></li> <li><code>[1, 2] + [3]</code> \u2192 <code>[1, 2, 3]</code></li> <li><code>[0] * 4</code> \u2192 <code>[0, 0, 0, 0]</code></li> </ul> <p>These behaviors highlight Python\u2019s flexible and dynamic typing system.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_3_operators_and_expressions.html#comparison-operators","title":"Comparison Operators","text":"<p>Comparison operators evaluate relationships between values and produce boolean results:</p> <ul> <li><code>==</code> (equal to)</li> <li><code>!=</code> (not equal to)</li> <li><code>&gt;</code> , <code>&lt;</code> (greater than, less than)</li> <li><code>&gt;=</code> , <code>&lt;=</code> (greater/less than or equal to)</li> </ul> <p>For example:</p> <p><pre><code>5 &lt; 10      # True\n\"cat\" == \"dog\"   # False\n</code></pre> Python compares strings lexicographically (alphabetical order based on Unicode).</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_3_operators_and_expressions.html#logical-operators","title":"Logical Operators","text":"<p>Logical operators combine boolean expressions:</p> <ul> <li><code>and</code> \u2014 True only if both sides are True</li> <li><code>or</code> \u2014 True if at least one side is True</li> <li><code>not</code> \u2014 negates a boolean value</li> </ul> <p>Python also uses the concepts of truthy and falsy values:</p> <ul> <li>Falsy examples: <code>0</code>, <code>\"\"</code>, <code>None</code>, <code>False</code>, empty lists/sets/dicts</li> <li>Everything else is truthy</li> </ul>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_3_operators_and_expressions.html#compound-assignment-operators","title":"Compound Assignment Operators","text":"<p>These update a variable by applying an operation and assignment in one step:</p> <ul> <li><code>+=</code></li> <li><code>=</code></li> <li><code>=</code></li> <li><code>/=</code></li> <li><code>//=</code></li> <li><code>%=</code></li> <li><code>*=</code></li> </ul> <p>Example:</p> <pre><code>x = 5\nx += 3   # x becomes 8\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_3_operators_and_expressions.html#operator-precedence","title":"Operator Precedence","text":"<p>Python evaluates expressions according to precedence rules:</p> <ol> <li>Parentheses <code>()</code></li> <li>Exponentiation <code>*</code></li> <li>Multiplication, division, modulo (<code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>)</li> <li>Addition, subtraction (<code>+</code>, <code>-</code>)</li> <li>Comparisons (<code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>)</li> <li>Logical <code>not</code>, <code>and</code>, <code>or</code></li> </ol> <p>Using parentheses makes expressions clearer and avoids ambiguity.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_3_operators_and_expressions.html#expression-evaluation","title":"Expression Evaluation","text":"<p>An expression is any combination of values, variables, and operators that Python evaluates to produce a result.</p> <p>Examples:</p> <p><pre><code>3 + 4 * 2        # 11\n(3 + 4) * 2      # 14\nTrue and (5 &gt; 3) # True\n</code></pre> Understanding how Python evaluates expressions is essential for writing correct programs.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_4_input_and_output.html","title":"2.4 Input and Output","text":"","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_4_input_and_output.html#output-with-print","title":"Output with <code>print()</code>","text":"<p>Programs often need to display information to the user.</p> <p>In Python, the primary tool for producing output is the <code>print()</code> function:</p> <p><pre><code>print(\"Hello, world!\")\n</code></pre> <code>print()</code> converts values to strings and displays them.</p> <p>By default, it ends output with a newline.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_4_input_and_output.html#deep-thoughts-of-jo-understanding-the-true-behavior-of-print","title":"Deep Thoughts of Jo \u2014 Understanding the True Behavior of print()","text":"<p>The <code>print()</code> function may look simple, but its behavior reveals important ideas about how Python functions work.</p> <p>Multiple arguments are separated by a space because of the default parameter <code>sep=\" \"</code>, and each call ends with a newline due to <code>end=\"\\n\"</code>.</p> <p>These defaults can be overridden, showing that Python functions combine predictability with flexibility.</p> <p>This leads to a key insight: Python functions have default arguments, and adjusting them allows customization without rewriting the function.</p> <p>When you learn about function definitions, keyword arguments, and API design, you will see this principle repeatedly.</p> <p>Developing the habit of asking why something behaves as it does is essential for a thoughtful engineer.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_4_input_and_output.html#string-formatting-in-python","title":"String Formatting in Python","text":"<p>When printing dynamic information, we often need to insert variables into strings.</p> <p>Python provides three major formatting styles, each created at a different time in Python\u2019s evolution.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_4_input_and_output.html#1-f-strings-recommended-modern","title":"1. f-strings (Recommended, Modern)","text":"<p>Introduced in Python 3.6, f-strings are the cleanest and most efficient way to format strings.</p> <p><pre><code>name = \"Alice\"\nage = 20\nprint(f\"My name is {name} and I am {age} years old.\")\n</code></pre> Pros:</p> <ul> <li>Most readable</li> <li>Fastest</li> <li>Supports inline expressions</li> </ul>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_4_input_and_output.html#2-strformat-older-still-common","title":"2. <code>str.format()</code> (Older, Still Common)","text":"<p>Before f-strings, the <code>.format()</code> method was the standard way to format strings.</p> <p><pre><code>print(\"My name is {} and I am {} years old.\".format(name, age))\n</code></pre> You can also reference arguments by index or name:</p> <pre><code>print(\"{1} is older than {0}\".format(\"Alice\", \"Bob\"))\nprint(\"{name} is {age}\".format(name=\"Alice\", age=20))\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_4_input_and_output.html#3-formatting-very-old-from-c-style-printf","title":"3. <code>%</code> Formatting (Very Old, from C-style printf)","text":"<p>This method comes from C\u2019s formatting style and is now mostly legacy:</p> <p><pre><code>print(\"My name is %s and I am %d years old.\" % (name, age))\n</code></pre> Still works, but offers fewer features and is considered outdated.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_4_input_and_output.html#which-one-should-you-use","title":"Which One Should You Use?","text":"<p>Use f-strings unless you have a specific reason not to.</p> <p>They are clearer, safer, and designed for modern Python.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_4_input_and_output.html#input-with-input","title":"Input with <code>input()</code>","text":"<pre><code>x = input(\"Enter something: \")\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_4_input_and_output.html#input-always-returns-a-string","title":"<code>input()</code> Always Returns a String","text":"<p><pre><code>x = input(\"Enter a number: \")\nprint(type(x))  # str\n</code></pre> Casting is required for numeric input:</p> <pre><code>x = int(input(\"Enter an integer: \"))\ny = float(input(\"Enter a floating-point number: \"))\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_4_input_and_output.html#combining-input-and-output","title":"Combining Input and Output","text":"<pre><code>name = input(\"Name: \")\nyear = int(input(\"Birth year: \"))\nage = 2025 - year\n\nprint(f\"Hello, {name}! You are {age} years old.\")\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_4_input_and_output.html#a-note-about-user-input-and-errors","title":"A Note About User Input and Errors","text":"<p>Unlike <code>print()</code>, which always behaves predictably, the <code>input()</code> function depends entirely on what the user types.</p> <p>This means the program may receive unexpected or invalid data.</p> <p>In the worst case, such input can cause errors\u2014for example, entering text when the program expects a number will raise a <code>ValueError</code> and immediately stop execution.</p> <p>This raises an important programming question:</p> <p>How can we prevent our program from crashing when the user makes a mistake? The answer is exception handling, a core technique that allows a program to detect and manage unexpected situations without stopping.</p> <p>You will learn how to use <code>try</code>, <code>except</code>, and other tools to make your programs robust and stable in a later chapter.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_5_control_flow_conditional_statements.html","title":"2.5 Control Flow \u2014 Conditional Statements","text":"<p>Conditional statements allow a program to make decisions.</p> <p>They let Python choose whether to execute certain lines of code based on whether a condition is <code>True</code> or <code>False</code>.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_5_control_flow_conditional_statements.html#why-conditions-matter","title":"Why Conditions Matter","text":"<p>Real-world problems often require different actions depending on the situation:</p> <ul> <li>\u201cIf the temperature is below 0\u00b0C, warn about freezing.\u201d</li> <li>\u201cIf the user enters a wrong password, deny access.\u201d</li> <li>\u201cIf there is no more data, stop reading.\u201d</li> </ul> <p>In programming, these decisions are expressed using conditional statements.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_5_control_flow_conditional_statements.html#the-if-statement","title":"The <code>if</code> Statement","text":"<p>The simplest form of a conditional statement is:</p> <p><pre><code>if condition:\n    # code runs only when condition is True\n</code></pre> Example:</p> <pre><code>x = 10\nif x &gt; 0:\n    print(\"x is positive\")\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_5_control_flow_conditional_statements.html#the-if-else-structure","title":"The <code>if-else</code> Structure","text":"<p>Use <code>else</code> when you want one of two possible paths to run:</p> <p><pre><code>if condition:\n    # runs when condition is True\nelse:\n    # runs when condition is False\n</code></pre> Example:</p> <pre><code>num = 3\n\nif num % 2 == 0:\n    print(\"Even\")\nelse:\n    print(\"Odd\")\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_5_control_flow_conditional_statements.html#multiple-conditions-elif","title":"Multiple Conditions: <code>elif</code>","text":"<p>Sometimes there are more than two possibilities.</p> <p><code>elif</code> (short for \u201celse if\u201d) allows for multiple branches:</p> <p><pre><code>if condition1:\n    ...\nelif condition2:\n    ...\nelif condition3:\n    ...\nelse:\n    ...\n</code></pre> Example:</p> <pre><code>score = 85\n\nif score &gt;= 90:\n    print(\"A\")\nelif score &gt;= 80:\n    print(\"B\")\nelif score &gt;= 70:\n    print(\"C\")\nelse:\n    print(\"D\")\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_5_control_flow_conditional_statements.html#nested-conditionals","title":"Nested Conditionals","text":"<p>Conditional statements can be placed inside one another:</p> <p><pre><code>x = 10\n\nif x &gt; 0:\n    if x % 2 == 0:\n        print(\"Positive even number\")\n</code></pre> Nested conditionals work, but deep nesting can make code harder to read.</p> <p>In later chapters, you will learn cleaner techniques such as boolean expressions and guard clauses.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_5_control_flow_conditional_statements.html#truthiness-in-python","title":"Truthiness in Python","text":"<p>In Python, conditions do not need to be actual <code>True</code> or <code>False</code> values.</p> <p>Many objects have an inherent \u201ctruthiness.\u201d</p> <p>The following evaluate to False:</p> <ul> <li><code>0</code></li> <li><code>0.0</code></li> <li><code>\"\"</code> (empty string)</li> <li><code>[]</code> (empty list)</li> <li><code>{}</code> (empty dict)</li> <li><code>None</code></li> <li><code>False</code> itself</li> </ul> <p>Everything else evaluates to True.</p> <p>Example:</p> <p><pre><code>name = \"\"\n\nif name:\n    print(\"You entered a name\")\nelse:\n    print(\"No name entered\")\n</code></pre> This prints:</p> <p><pre><code>No name entered\n</code></pre> because an empty string is considered False.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_5_control_flow_conditional_statements.html#summary","title":"Summary","text":"<p>Conditional statements allow programs to:</p> <ul> <li>test conditions</li> <li>choose different paths</li> <li>react to user input</li> <li>enforce rules or constraints</li> </ul> <p>They are one of the most fundamental tools in programming, forming the basis of decision-making in software.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_6_control_flow_loops.html","title":"2.6 Control Flow \u2014 Loops","text":"<p>Loops allow a program to repeat actions efficiently.</p> <p>They are essential in programming because many tasks require performing the same operation multiple times\u2014processing datasets, iterating numerical updates, or repeatedly checking conditions.</p> <p>Python provides two main loop types\u2014<code>while</code> and <code>for</code>\u2014and several control statements (<code>break</code>, <code>continue</code>, <code>pass</code>) that determine how loops behave.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_6_control_flow_loops.html#the-while-loop","title":"The <code>while</code> Loop","text":"<p>A <code>while</code> loop repeats its body as long as a condition remains <code>True</code>.</p> <p><pre><code>while condition:\n    # repeated code\n</code></pre> Example:</p> <pre><code>count = 0\nwhile count &lt; 3:\n    print(\"Hello\")\n    count += 1\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_6_control_flow_loops.html#when-to-use-a-while-loop","title":"When to Use a <code>while</code> Loop","text":"<p>Use it when:</p> <ul> <li>the number of repetitions is unknown</li> <li>repetition must continue until some condition changes</li> <li>you are waiting for a specific event (user input, sensor data, etc.)</li> </ul>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_6_control_flow_loops.html#the-for-loop","title":"The <code>for</code> Loop","text":"<p>A <code>for</code> loop iterates over a sequence:</p> <p><pre><code>for item in sequence:\n    # repeated code\n</code></pre> Example:</p> <pre><code>for ch in \"AI\":\n    print(ch)\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_6_control_flow_loops.html#when-to-use-a-for-loop","title":"When to Use a <code>for</code> Loop","text":"<p>Use <code>for</code> when you know what you are iterating over\u2014lists, strings, ranges, and other iterable objects.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_6_control_flow_loops.html#the-range-function","title":"The <code>range()</code> Function","text":"<p><code>range()</code> generates integer sequences commonly used for iterative tasks.</p> <p><pre><code>range(stop)\nrange(start, stop)\nrange(start, stop, step)\n</code></pre> Example:</p> <pre><code>for i in range(3):\n    print(i)\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_6_control_flow_loops.html#loop-variables","title":"Loop Variables","text":"<p>The loop variable takes on each value in the iteration sequence.</p> <p>Although Python keeps this variable available after the loop, many other languages do not.</p> <pre><code>for x in [1, 2, 3]:\n    print(x)\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_6_control_flow_loops.html#break-exit-the-loop-immediately","title":"<code>break</code> \u2014 exit the loop immediately","text":"<p><code>break</code> stops the loop entirely, regardless of the condition or remaining elements.</p> <p><pre><code>for n in [1, 2, 3, 99, 4]:\n    if n == 99:\n        break\n    print(n)\n</code></pre> Output:</p> <p><pre><code>1\n2\n3\n</code></pre> Useful when:</p> <ul> <li>a desired value is found</li> <li>further processing is unnecessary</li> <li>the loop must terminate early</li> </ul>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_6_control_flow_loops.html#continue-skip-the-current-iteration","title":"<code>continue</code> \u2014 skip the current iteration","text":"<p><code>continue</code> jumps to the next iteration of the loop without executing the remaining code in the loop body.</p> <p><pre><code>for n in range(5):\n    if n % 2 == 0:\n        continue\n    print(n)\n</code></pre> Output:</p> <p><pre><code>1\n3\n</code></pre> Useful for:</p> <ul> <li>skipping invalid or unneeded values</li> <li>filtering data inside a loop</li> </ul>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_6_control_flow_loops.html#pass-do-nothing","title":"<code>pass</code> \u2014 do nothing","text":"<p><code>pass</code> is a no-operation placeholder.</p> <p>It does nothing but allows for syntactically complete code.</p> <p><pre><code>for n in range(3):\n    pass\n</code></pre> Common uses:</p> <ul> <li>when planning code structure</li> <li>when stubbing out functions or classes</li> <li>when a loop must exist syntactically but perform no actions</li> </ul>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_6_control_flow_loops.html#loops-in-problem-solving","title":"Loops in Problem Solving","text":"<p>Loops enable tasks such as:</p> <ul> <li>iterating through data</li> <li>aggregating results</li> <li>searching for values</li> <li>building simulations</li> <li>performing iterative numerical algorithms (gradient descent, optimization)</li> </ul> <p>Understanding loops and loop control statements builds the foundation for algorithmic thinking.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_7_functions.html","title":"Functions","text":"<p>Functions are reusable blocks of code designed to perform specific tasks.</p> <p>They allow programs to be organized into small, meaningful pieces and help avoid repetition.</p> <p>Learning to write good functions is essential for writing clear, modular, and maintainable programs.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_7_functions.html#why-functions-matter","title":"Why Functions Matter","text":"<p>Functions are important because they:</p> <ul> <li>group related operations into a single unit</li> <li>reduce code duplication</li> <li>improve readability and structure</li> <li>allow decomposition of large problems into smaller parts</li> <li>support abstraction \u2014 hiding unnecessary detail</li> </ul> <p>In real engineering work, functions are the building blocks from which entire systems are constructed.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_7_functions.html#defining-a-function","title":"Defining a Function","text":"<p>You define a function using the <code>def</code> keyword:</p> <p><pre><code>def function_name(parameters):\n    # code block\n    return value\n</code></pre> Example:</p> <p><pre><code>def square(x):\n    return x * x\n</code></pre> Calling the function:</p> <pre><code>result = square(3)\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_7_functions.html#parameters-and-arguments","title":"Parameters and Arguments","text":"<ul> <li>parameters: variables listed in the function definition</li> <li>arguments: actual values passed when calling the function</li> </ul> <p>Example:</p> <pre><code>def greet(name):   # name is a parameter\n    print(\"Hello,\", name)\n\ngreet(\"Jo\")        # \"Jo\" is an argument\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_7_functions.html#return-values","title":"Return Values","text":"<p><code>return</code> sends a value back to the caller.</p> <p><pre><code>def add(a, b):\n    return a + b\n\nx = add(2, 3)\n</code></pre> If a function does not have a <code>return</code> statement, it returns <code>None</code> by default.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_7_functions.html#default-parameters","title":"Default Parameters","text":"<p>Functions can have default values for parameters:</p> <p><pre><code>def power(base, exponent=2):\n    return base ** exponent\n</code></pre> Usage:</p> <p><pre><code>power(3)      # 9\npower(3, 3)   # 27\n</code></pre> Default parameters are useful when a value is optional or a common default exists.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_7_functions.html#variable-scope-basic","title":"Variable Scope (Basic)","text":"<p>Variables created inside a function are local to that function:</p> <p><pre><code>def func():\n    x = 10  # local variable\n</code></pre> Variables created outside a function are global:</p> <p><pre><code>x = 5\n\ndef show():\n    print(x)\n</code></pre> A more detailed discussion of scope rules (LEGB rule) comes later in the advanced Functions chapter.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_7_functions.html#docstrings","title":"Docstrings","text":"<p>Functions can include documentation:</p> <p><pre><code>def add(a, b):\n    \"\"\"Return the sum of a and b.\"\"\"\n    return a + b\n</code></pre> Docstrings help others understand your function\u2019s purpose.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_7_functions.html#functions-and-problem-solving","title":"Functions and Problem Solving","text":"<p>Functions enable:</p> <ul> <li>decomposition of large algorithms</li> <li>reusable components</li> <li>cleaner experimental code</li> <li>building libraries</li> <li>writing maintainable software</li> </ul> <p>They are one of the most powerful tools in Python programming.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_8_error_types_and_basic_exception_handling.html","title":"2.8 Error Types and Basic Exception Handling","text":"<p>Errors are an inevitable part of programming.</p> <p>They occur when Python encounters something it cannot interpret or execute.</p> <p>Understanding different error types\u2014and how to handle them\u2014is essential for writing reliable programs.</p> <p>Python handles unexpected situations using a mechanism called exceptions,</p> <p>and programmers can use exception handling to control how a program responds when an error occurs.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_8_error_types_and_basic_exception_handling.html#common-error-types","title":"Common Error Types","text":"<p>Here are some of the most frequent errors you will encounter:</p> <ul> <li>SyntaxError: Occurs when Python cannot parse the code</li> <li>NameError: Occurs when a variable or function name is not defined</li> <li>TypeError: Occurs when an operation is applied to the wrong data type</li> <li>ValueError: Occurs when a variable has the right type but an inappropriate content</li> <li>IndexError: Occurs when indexing outside valid bounds</li> <li>ZeroDivisionError: Occurs when dividing by zero</li> </ul>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_8_error_types_and_basic_exception_handling.html#why-exception-handling-matters","title":"Why Exception Handling Matters","text":"<p>Without handling errors, a program simply stops when something unexpected happens.</p> <p>This is dangerous when:</p> <ul> <li>user input is incorrect</li> <li>data is incomplete</li> <li>network requests fail</li> <li>files are missing</li> <li>numerical computations reach invalid states</li> </ul> <p>To build robust programs, we must handle errors gracefully instead of crashing.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_8_error_types_and_basic_exception_handling.html#basic-exception-handling-try-and-except","title":"Basic Exception Handling: <code>try</code> and <code>except</code>","text":"<p>The <code>try</code> block allows you to test code for errors.</p> <p>The <code>except</code> block lets you define what happens when an error occurs.</p> <p><pre><code>try:\n    x = int(input(\"Enter a number: \"))\n    print(\"You entered:\", x)\nexcept ValueError:\n    print(\"Invalid input. Please enter a number.\")\n</code></pre> Instead of the program crashing when the user enters something invalid,</p> <p>we can show a helpful message.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_8_error_types_and_basic_exception_handling.html#catching-multiple-exceptions","title":"Catching Multiple Exceptions","text":"<pre><code>try:\n    x = int(\"abc\")\n    y = 10 / 0\nexcept ValueError:\n    print(\"ValueError occurred\")\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero\")\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_8_error_types_and_basic_exception_handling.html#a-general-except","title":"A General <code>except</code>","text":"<p>Sometimes you want to handle any error:</p> <p><pre><code>try:\n    risky_function()\nexcept Exception:\n    print(\"Something went wrong.\")\n</code></pre> Use this with caution\u2014it's helpful for debugging or protecting large systems,</p> <p>but should not replace specific exception handling.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_8_error_types_and_basic_exception_handling.html#else-and-finally-basic-overview","title":"<code>else</code> and <code>finally</code> (Basic Overview)","text":"<p><pre><code>try:\n    x = int(\"10\")\nexcept ValueError:\n    print(\"Invalid number\")\nelse:\n    print(\"Conversion succeeded\")\nfinally:\n    print(\"This always runs\")\n</code></pre> - <code>else</code>: runs only if no exceptions occur - <code>finally</code>: always runs, used for cleanup (closing files, freeing resources, etc.)</p> <p>You will revisit <code>else</code> and <code>finally</code> in more depth later.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_8_error_types_and_basic_exception_handling.html#exception-handling-and-problem-solving","title":"Exception Handling and Problem Solving","text":"<p>Exception handling lets programmers build programs that:</p> <ul> <li>are safe</li> <li>provide meaningful feedback</li> <li>avoid unexpected crashes</li> <li>handle unpredictable input or data</li> <li>remain stable under real-world conditions</li> </ul> <p>This is especially important for AI/ML systems where data reliability is critical.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_9_comments_and_code_style.html","title":"2.9 Comments and Code Style","text":"<p>Readable code is just as important as correct code.</p> <p>As programs grow larger, clarity becomes essential \u2014 not only for other people reading your code, but also for your future self.</p> <p>Python encourages clean style and clear intentions through comments and formatting conventions.</p> <p>Good code is not only about making the computer understand your instructions.</p> <p>It is about writing code that humans can understand.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_9_comments_and_code_style.html#comments","title":"Comments","text":"","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_9_comments_and_code_style.html#single-line-comments","title":"Single-line Comments","text":"<p>In Python, comments begin with <code>#</code>.</p> <p>Anything after the <code>#</code> on the same line is ignored by Python.</p> <p><pre><code># This computes the area of a circle\narea = 3.14 * r * r\n</code></pre> Use comments to explain why something is being done, not what is being done.</p> <p>If your code is clear, the \u201cwhat\u201d should already be obvious.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_9_comments_and_code_style.html#docstrings","title":"Docstrings","text":"<p>Functions, classes, and modules can include multi-line documentation strings.</p> <p><pre><code>def add(a, b):\n    \"\"\"Return the sum of a and b.\"\"\"\n    return a + b\n</code></pre> Docstrings are used by tools such as IDEs, documentation generators, and help systems.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_9_comments_and_code_style.html#indentation","title":"Indentation","text":"<p>Python uses indentation to define code blocks, not braces <code>{}</code>.</p> <p>This makes indentation part of Python\u2019s syntax and one of its most distinctive features.</p> <p>Standard indentation is 4 spaces per level.</p> <p><pre><code>if x &gt; 0:\n    print(\"Positive\")\n</code></pre> Avoid mixing tabs and spaces.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_9_comments_and_code_style.html#line-length","title":"Line Length","text":"<p>PEP 8 \u2014 Python\u2019s official style guide \u2014 recommends:</p> <ul> <li>Maximum line length: 79 characters</li> <li>For docstrings and comments: 72 characters This keeps code readable on various screens and tools.</li> </ul>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_9_comments_and_code_style.html#naming-conventions","title":"Naming Conventions","text":"<p>Python follows common naming styles:</p> <ul> <li>variables/functions: <code>lowercase_with_underscores</code></li> <li>classes: <code>CamelCase</code></li> <li>constants: <code>UPPERCASE_WITH_UNDERSCORES</code> Examples:</li> </ul> <p><pre><code>user_name = \"Jo\"\nMAX_SIZE = 1000\n\nclass DataLoader:\n    pass\n</code></pre> Good names make code self-explanatory.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_9_comments_and_code_style.html#blank-lines-and-organization","title":"Blank Lines and Organization","text":"<p>Use blank lines to separate logical sections of code.</p> <p>Good spacing improves readability by grouping related logic.</p> <pre><code># Load data\nload_data()\n\n# Process data\nprocess_data()\n\n# Save output\nsave_results()\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_2/sec_9_comments_and_code_style.html#why-code-style-matters","title":"Why Code Style Matters","text":"<p>Code is communication \u2014 between you and whoever reads your code.</p> <p>Clean style helps:</p> <ul> <li>reduce bugs</li> <li>make programs easier to modify</li> <li>improve collaboration</li> <li>make your thinking clearer</li> </ul> <p>Professional engineers follow style guides not because computers need it,</p> <p>but because humans do.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_3/sec_1_strings.html","title":"3.1 Strings","text":"<p>So far, we have worked with text values in Python as simple inputs or outputs.</p> <p>However, unlike numbers such as <code>int</code> or <code>float</code>, a string is not a single, atomic value.</p> <p>A string is a data structure\u2014specifically, an ordered sequence of characters.</p> <p>Understanding strings as data structures is essential, because text data appears everywhere:</p> <p>user input, file contents, logs, configuration files, datasets, and natural language data.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_3/sec_1_strings.html#strings-as-sequence-data-structures","title":"Strings as Sequence Data Structures","text":"<p>In Python, a string behaves like an array (or sequence):</p> <ul> <li>it has a length</li> <li>it supports indexing</li> <li>it supports slicing</li> <li>it can be iterated over <pre><code>s = \"AI\"\nprint(s[0])   # 'A'\nprint(s[1])   # 'I'\n</code></pre> However, Python does not provide a built-in <code>char</code> type.</li> </ul> <p>There is no single-character primitive type in Python.</p> <p>In contrast, languages like C define:</p> <p><pre><code>char c = 'A';\n</code></pre> In Python, even a single character is still a string:</p> <p><pre><code>c = \"A\"\ntype(c)   # str\n</code></pre> This design choice simplifies the language and removes the need to distinguish between <code>char</code> and <code>string</code>.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_3/sec_1_strings.html#immutability-of-strings","title":"Immutability of Strings","text":"<p>Strings in Python are immutable.</p> <p>Once a string object is created, its contents cannot be changed.</p> <p><pre><code>s = \"hello\"\ns[0] = \"H\"   # TypeError\n</code></pre> Any operation that appears to modify a string actually creates a new string object.</p> <p><pre><code>s = s.upper()\n</code></pre> This immutability has important consequences for:</p> <ul> <li>memory management</li> <li>performance</li> <li>safety and predictability</li> </ul>","tags":[]},{"location":"Computer_Science/Python/chapter_3/sec_1_strings.html#common-string-functions-and-methods","title":"Common String Functions and Methods","text":"<p>Python provides many built-in tools for working with strings.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_3/sec_1_strings.html#length-and-counting","title":"Length and Counting","text":"<pre><code>len(s)       # returns the number of characters in the string\ns.count(\"a\") # returns how many times \"a\" appears in the string\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_3/sec_1_strings.html#whitespace-handling","title":"Whitespace Handling","text":"<pre><code>s.strip()  # removes left and right whitespace\ns.lstrip() # removes left whitespace only\ns.rstrip() # removes right whitespace only\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_3/sec_1_strings.html#splitting-and-joining","title":"Splitting and Joining","text":"<pre><code>s.split(\",\")              # (str-&gt;list) splits a string into a list using \",\" as delimeter\n\" \".join([\"a\", \"b\", \"c\"]) # (list-&gt;str) joins a list of strings into one string with spaces\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_3/sec_1_strings.html#replacing-and-searching","title":"Replacing and Searching","text":"<pre><code>s.replace(\"old\", \"new\") # returns a new string with substrings replaced\ns.find(\"sub\")           # returns the index of first occurence, or -1 if not found\n</code></pre>","tags":[]},{"location":"Computer_Science/Python/chapter_3/sec_1_strings.html#case-conversion","title":"Case Conversion","text":"<p><pre><code>s.upper()      # returns a copy with all characters in uppercase\ns.lower()      # returns a copy with all characters in lowercase\ns.capitalize() # returns a copy with the first character caplitalized\n</code></pre> These methods allow strings to be transformed, analyzed, and prepared for further processing.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_3/sec_1_strings.html#strings-and-memory-conceptual-view","title":"Strings and Memory (Conceptual View)","text":"<p>Although Python hides low-level memory management, conceptually:</p> <ul> <li>a string is stored as a contiguous sequence of characters in memory</li> <li>indexing accesses characters by offset</li> <li>immutability ensures that shared string data remains safe</li> </ul> <p>When a string is modified, Python allocates new memory and copies the data.</p> <p>This makes string operations safe but can be expensive if done repeatedly in loops.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_3/sec_1_strings.html#why-strings-matter-in-practice","title":"Why Strings Matter in Practice","text":"<p>Strings are central to real-world programming:</p> <ul> <li>parsing user input</li> <li>reading files</li> <li>processing text data</li> <li>building datasets</li> <li>interacting with external systems</li> </ul> <p>In AI and data science, text data is often the raw input that must be cleaned, tokenized, and transformed before any model can be applied.</p> <p>Understanding strings as immutable sequence data structures prepares you for more advanced text processing and data manipulation techniques.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_3/sec_2_lists.html","title":"3.2 Lists","text":"<p>A list is one of the most fundamental and widely used data structures in Python.</p> <p>Unlike strings, lists are mutable, which means their contents can be changed after creation.</p> <p>Lists are designed to store collections of objects and provide flexible ways to organize, access, and modify data.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_3/sec_2_lists.html#indexing-and-slicing","title":"Indexing and Slicing","text":"<p>Like strings, lists are ordered sequences and support indexing.</p> <p><pre><code>numbers = [10, 20, 30, 40]\nnumbers[0]     # 10\nnumbers[-1]    # 40\n</code></pre> Slicing allows access to a sublist:</p> <p><pre><code>numbers[1:3]   # [20, 30]\nnumbers[:2]    # [10, 20]\nnumbers[::2]   # [10, 30]\n</code></pre> Slicing always returns a new list, not a view of the original.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_3/sec_2_lists.html#mutability-and-modification","title":"Mutability and Modification","text":"<p>Lists can be modified in place:</p> <p><pre><code>numbers[1] = 25\nnumbers.append(50)\nnumbers.remove(30)\n</code></pre> This mutability allows lists to grow, shrink, and change dynamically,</p> <p>making them ideal for tasks such as data accumulation and iterative processing.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_3/sec_2_lists.html#nested-lists-lists-of-lists","title":"Nested Lists (Lists of Lists)","text":"<p>A list can contain other lists as elements.</p> <p><pre><code>matrix = [\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n]\n</code></pre> Accessing elements in a nested list uses multiple indices:</p> <p><pre><code>matrix[0]      # [1, 2, 3]\nmatrix[0][1]   # 2\n</code></pre> Nested lists are commonly used to represent:</p> <ul> <li>matrices and grids</li> <li>tabular data</li> <li>hierarchical structures</li> </ul> <p>Understanding index-of-index access is essential when working with multi-dimensional data.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_3/sec_2_lists.html#lists-and-iteration","title":"Lists and Iteration","text":"<p>Lists are naturally suited for iteration:</p> <p><pre><code>for value in numbers:\n    print(value)\n</code></pre> They also integrate seamlessly with list comprehensions:</p> <p><pre><code>squares = [x * x for x in numbers]\n</code></pre> This allows concise and expressive data transformations.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_3/sec_2_lists.html#lists-and-memory-conceptual-model","title":"Lists and Memory (Conceptual Model)","text":"<p>From a conceptual standpoint, Python lists are not the same as C arrays.</p> <ul> <li>A C array stores elements contiguously in memory.</li> <li>A Python list stores references (pointers) to objects.</li> </ul> <p>In other words:</p> <ul> <li>the list itself holds references</li> <li>each element lives separately in memory</li> <li>the list points to those elements</li> </ul> <p>This design makes Python lists more flexible than fixed-size arrays,</p> <p>but also means:</p> <ul> <li>accessing elements involves pointer dereferencing</li> <li>lists can store mixed data types</li> <li>resizing is handled dynamically</li> </ul> <p>While Python lists are not classic linked lists,</p> <p>their behavior is closer to a dynamic array of references rather than a raw memory block.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_3/sec_2_lists.html#list-copying-and-aliasing","title":"List Copying and Aliasing","text":"<p>Because lists are mutable, copying behavior is important.</p> <p><pre><code>a = [1, 2, 3]\nb = a\n</code></pre> Here, <code>a</code> and <code>b</code> refer to the same list.</p> <p>To create a shallow copy:</p> <p><pre><code>b = a.copy()\n# or\nb = a[:]\n</code></pre> Understanding this distinction is critical to avoiding unintended side effects.</p>","tags":[]},{"location":"Computer_Science/Python/chapter_3/sec_2_lists.html#why-lists-matter","title":"Why Lists Matter","text":"<p>Lists are used everywhere:</p> <ul> <li>collecting results</li> <li>storing intermediate data</li> <li>representing datasets</li> <li>building higher-level data structures</li> </ul> <p>They form the backbone of many Python programs and serve as the foundation for more advanced structures such as NumPy arrays and pandas DataFrames.</p>","tags":[]}]}